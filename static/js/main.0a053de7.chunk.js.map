{"version":3,"sources":["components/AddressSearch.tsx","components/Legends.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["AddressSearch","props","React","useState","inputValue","setInputValue","options","setOptions","useEffect","active","a","url","fetch","encodeURI","jsonResponse","json","response","results","handleChange","event","target","value","Autocomplete","id","style","width","filterOptions","x","getOptionLabel","option","fulltext","noOptionsText","autoComplete","onChange","reason","onAddressSelected","includeInputInList","renderInput","params","TextField","placeholder","variant","Legends","Paper","elevation","padding","Typography","display","gutterBottom","textAlign","color","green","verticalAlign","blueGrey","App","location","setLocation","polygon","setPolygon","lng","lat","ok","lngLatArray","wktGeometry","split","map","lngLat","trim","Number","className","FormControl","backgroundColor","address","y","Map","center","zoom","animate","TileLayer","attribution","Fragment","Marker","position","Popup","length","Circle","fillColor","radius","Polygon","positions","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0a053de7.chunk.js","sourcesContent":["import React from 'react';\nimport TextField from '@material-ui/core/TextField';\nimport Autocomplete from '@material-ui/lab/Autocomplete';\nimport { AutocompleteChangeReason } from '@material-ui/lab/useAutocomplete/useAutocomplete';\n\ninterface Response {\n    results: Address[];\n    status: string;\n}\n\ninterface Address {\n    kind: string;\n    city: string;\n    zipcode: string;\n    street: string;\n    fulltext: string;\n    classification: number;\n    country: string;\n    x: number;\n    y: number;\n}\n\ninterface AddressSearchProps {\n    onAddressSelected: (address: Address) => any;\n}\n\nexport default function AddressSearch(props: AddressSearchProps) {\n    const [inputValue, setInputValue] = React.useState('');\n    const [options, setOptions] = React.useState<Address[]>([]);\n\n    React.useEffect(() => {\n        let active = true;\n\n        (async () => {\n            const url = `https://wxs.ign.fr/an7nvfzojv5wa96dsga5nk8w/ols/apis/completion?gp-access-lib=2.1.6&text=${inputValue}&type=PositionOfInterest,StreetAddress&terr&maximumResponses=5`;\n            const jsonResponse = await fetch(encodeURI(url));\n            const response: Response = await jsonResponse.json();\n            if (active) {\n                setOptions(response.results);\n            }\n        })();\n\n        return () => {\n            active = false;\n        };\n    }, [inputValue]);\n\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        setInputValue(event.target.value);\n    };\n\n    return (\n        <Autocomplete\n            id=\"asynchronous-demo\"\n            style={{ width: '100%' }}\n            filterOptions={(x) => x}\n            getOptionLabel={(option) => option.fulltext}\n            options={options}\n            noOptionsText=\"Adresse non trouvée\"\n            autoComplete\n            onChange={(event: React.ChangeEvent<{}>, value: Address | null, reason: AutocompleteChangeReason) => {\n                if (reason === 'select-option' && value) {\n                    props.onAddressSelected(value);\n                }\n            }}\n            includeInputInList\n            renderInput={(params) => (\n                <TextField\n                    {...params}\n                    placeholder=\"Tapez votre adresse ici\"\n                    variant=\"outlined\"\n                    onChange={handleChange}\n                />\n            )}\n        />\n    );\n}\n","import React from 'react';\nimport { Paper, Typography } from '@material-ui/core';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport { blueGrey, green } from '@material-ui/core/colors';\n\nexport default function Legends() {\n    return (\n        <Paper elevation={3} style={{ padding: '10px' }}>\n            <Typography variant=\"caption\" display=\"block\" gutterBottom style={{ textAlign: 'left' }}>\n                <FiberManualRecordIcon style={{ color: green[500], verticalAlign: 'middle' }} />\n                Zone piétonne fournie par IGN\n            </Typography>\n            <Typography variant=\"caption\" display=\"block\" gutterBottom style={{ textAlign: 'left' }}>\n                <FiberManualRecordIcon style={{ color: blueGrey[500], verticalAlign: 'middle' }} />\n                Rayon d'un kilomètre autour de l'adresse\n            </Typography>\n        </Paper>\n    );\n}\n","import React from 'react';\nimport { Circle, Map, Marker, Polygon, Popup, TileLayer } from 'react-leaflet';\nimport { default as Leaflet, LatLngLiteral } from 'leaflet';\n\nimport { FormControl, Paper, Typography } from '@material-ui/core';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport { blueGrey, green } from '@material-ui/core/colors';\n\nimport './App.css';\nimport AddressSearch from './components/AddressSearch';\nimport Legends from './components/Legends';\n\ninterface Response {\n    status: string;\n    wktGeometry: string; // \"POLYGON ((4.852567 45.735057, 4.851924 45.735057, 4.851924 45.735496, 4.851924 45.735934, 4.851924 45.736373, 4.851924 45.736812, 4.851282 45.735496, 4.85064 45.735057, 4.849998 45.735057, 4.849998 45.735496, 4.849998 45.735934, 4.848071 45.736373, 4.847428 45.736812, 4.847428 45.73725, 4.848071 45.73725, 4.848713 45.73725, 4.849355 45.73725, 4.849355 45.739004, 4.848713 45.739443, 4.848071 45.74032, 4.847428 45.741636, 4.845501 45.742952, 4.844217 45.74339, 4.842932 45.744267, 4.84229 45.74339, 4.841648 45.74339, 4.841005 45.74339, 4.840363 45.74339, 4.840363 45.743829, 4.840363 45.744267, 4.839721 45.745145, 4.839721 45.746022, 4.840363 45.746022, 4.841005 45.748215, 4.843575 45.749969, 4.846786 45.750846, 4.847428 45.750846, 4.848071 45.750846, 4.848713 45.750846, 4.848713 45.750408, 4.849355 45.750846, 4.849998 45.750846, 4.85064 45.750846, 4.851924 45.750846, 4.852567 45.750846, 4.853209 45.750408, 4.853851 45.750408, 4.854494 45.750408, 4.855778 45.74953, 4.855778 45.749092, 4.857063 45.747776, 4.857705 45.747776, 4.858348 45.747338, 4.858348 45.746899, 4.857705 45.74646, 4.85899 45.746022, 4.859632 45.745583, 4.859632 45.745145, 4.859632 45.744706, 4.859632 45.744267, 4.859632 45.743829, 4.859632 45.74339, 4.859632 45.742952, 4.860275 45.742952, 4.860917 45.742952, 4.862201 45.741636, 4.862201 45.741197, 4.862201 45.740759, 4.861559 45.740759, 4.860917 45.740759, 4.860917 45.739443, 4.861559 45.739443, 4.861559 45.739004, 4.860917 45.738127, 4.860275 45.738127, 4.85899 45.737689, 4.856421 45.73725, 4.856421 45.736373, 4.856421 45.735934, 4.856421 45.735496, 4.855778 45.735496, 4.853851 45.734619, 4.853209 45.734619, 4.852567 45.735057))\"\n}\n\nfunction App() {\n    const parisLocation: LatLngLiteral = {\n        lat: 48.866667,\n        lng: 2.333333,\n    };\n\n    const [location, setLocation] = React.useState<LatLngLiteral | null>(null);\n    const [polygon, setPolygon] = React.useState<Leaflet.LatLngLiteral[]>([]);\n\n    React.useEffect(() => {\n        let active = true;\n\n        if (location) {\n            (async () => {\n                const url = `https://wxs.ign.fr/an7nvfzojv5wa96dsga5nk8w/isochrone/isochrone.json?gp-access-lib=2.1.6&location=${location.lng},${location.lat}&smoothing=true&holes=false&reverse=false&method=distance&distance=1000&graphName=Pieton&exclusions&srs=EPSG:4326`;\n                const jsonResponse = await fetch(encodeURI(url));\n                if (jsonResponse.ok) {\n                    const response: Response = await jsonResponse.json();\n                    const lngLatArray = response.wktGeometry\n                        .split('((')[1]\n                        .split(')')[0]\n                        .split(',')\n                        .map((lngLat) => {\n                            return lngLat.trim().split(' ');\n                        });\n                    if (active) {\n                        setPolygon(\n                            lngLatArray.map((lngLat) => {\n                                return { lng: Number(lngLat[0]), lat: Number(lngLat[1]) };\n                            }),\n                        );\n                    }\n                }\n            })();\n        }\n\n        return () => {\n            active = false;\n        };\n    }, [location]);\n\n    return (\n        <div className=\"App\">\n            <div className=\"locationInput\">\n                <FormControl style={{ backgroundColor: 'white', width: '50%' }}>\n                    <AddressSearch\n                        onAddressSelected={(address) => {\n                            setLocation({\n                                lat: address.y,\n                                lng: address.x,\n                            });\n                        }}\n                    />\n                </FormControl>\n            </div>\n            <Map center={location ? location : parisLocation} zoom={13} animate={true}>\n                <TileLayer\n                    attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n                    url=\"https://{s}.tile.osm.org/{z}/{x}/{y}.png\"\n                />\n                {location && (\n                    <React.Fragment>\n                        <Marker position={location}>\n                            <Popup>Vous êtes ici !</Popup>\n                        </Marker>\n                        {polygon.length > 0 && (\n                            <React.Fragment>\n                                <Circle\n                                    center={location}\n                                    color={blueGrey[500]}\n                                    fillColor={blueGrey[500]}\n                                    radius={1000}\n                                />\n                                <Polygon color={green[500]} positions={polygon} />\n                            </React.Fragment>\n                        )}\n                    </React.Fragment>\n                )}\n            </Map>\n            <div className=\"legend\">\n                <Legends />\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.0/8 are considered localhost for IPv4.\n        window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://bit.ly/CRA-PWA',\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: { 'Service-Worker': 'script' },\n    })\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log('No internet connection found. App is running in offline mode.');\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready\n            .then((registration) => {\n                registration.unregister();\n            })\n            .catch((error) => {\n                console.error(error.message);\n            });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}